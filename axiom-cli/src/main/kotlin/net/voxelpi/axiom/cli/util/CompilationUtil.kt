package net.voxelpi.axiom.cli.util

import com.github.ajalt.mordant.rendering.TextColors
import com.github.ajalt.mordant.rendering.TextStyles
import net.voxelpi.axiom.asm.exception.CompilationException
import net.voxelpi.axiom.asm.exception.ParseException
import net.voxelpi.axiom.asm.exception.SourceCompilationException
import net.voxelpi.axiom.asm.source.SourceLink
import kotlin.text.isWhitespace

private val sourceTextStyle = TextColors.brightCyan
private val sourceRefStyle = TextColors.brightYellow
private val sourceUnitStyle = TextColors.brightGreen
private val errorStyle = TextColors.brightRed

fun generateCompilationStackTraceMessage(exception: Throwable): String {
    val lines = mutableListOf<String>()
    buildCompilationStackTrace(exception, lines)
    return lines.joinToString("\n") { it }
}

private fun errorSourceText(source: SourceLink.CompilationUnitSlice): String {
    var iStatementStart = source.index
    while (iStatementStart > 0) {
        --iStatementStart
        if (source.unit.content[iStatementStart] in listOf('\n', '\r', ';')) {
            ++iStatementStart
            break
        }
    }
    while (iStatementStart < source.index + source.length) {
        if (!source.unit.content[iStatementStart].isWhitespace()) {
            break
        }
        ++iStatementStart
    }

    var iStatementEnd = source.index + source.length
    while (iStatementEnd < source.unit.content.length) {
        if (source.unit.content[iStatementEnd] in listOf('\n', '\r', ';')) {
            break
        }
        ++iStatementEnd
    }
    while (iStatementEnd > iStatementStart) {
        if (!source.unit.content[iStatementEnd - 1].isWhitespace()) {
            break
        }
        --iStatementEnd
    }

    val statementText = source.unit.content.substring(iStatementStart, iStatementEnd)
    val highlightStart = (source.index - iStatementStart).coerceAtLeast(0)
    val highlightEnd = highlightStart + (source.length).coerceAtMost(iStatementEnd - iStatementStart)
    return "\"${statementText.substring(0, highlightStart)}${TextStyles.underline(statementText.substring(highlightStart, highlightEnd))}${statementText.substring(highlightEnd)}\""
}

private fun buildCompilationStackTrace(exception: Throwable, messages: MutableList<String>) {
    val prefix = TextColors.gray("${"    ".repeat(messages.size)}  â”” ")
    when (exception) {
        is ParseException -> {
            val source = exception.source
            when (source) {
                is SourceLink.CompilationUnitSlice -> {
                    messages += "$prefix Failed to parse ${sourceTextStyle(errorSourceText(source))} at ${sourceRefStyle("${source.line + 1}")}:${sourceRefStyle("${source.column + 1}")} of unit ${sourceUnitStyle("\"${source.unit.id}\"")}: ${errorStyle(exception.message ?: "")}"
                }
                is SourceLink.Generated -> {
                    messages += "$prefix Failed to parse ${sourceTextStyle("\"${source.text}\"")} ${sourceRefStyle("generated by \"${source.generator}\"")}: ${errorStyle(exception.message ?: "")}"
                }
            }
        }
        is SourceCompilationException -> {
            val source = exception.source
            when (source) {
                is SourceLink.CompilationUnitSlice -> {
                    messages += "$prefix Failed to compile ${sourceTextStyle(errorSourceText(source))} at ${sourceRefStyle("${source.line + 1}")}:${sourceRefStyle("${source.column + 1}")} of unit ${sourceUnitStyle("\"${source.unit.id}\"")}: ${errorStyle(exception.message ?: "")}"
                }
                is SourceLink.Generated -> {
                    messages += "$prefix Failed to compile ${sourceTextStyle("\"${source.text}\"")} ${sourceRefStyle("generated by \"${source.generator}\"")}: ${errorStyle(exception.message ?: "")}"
                }
            }
        }
        is CompilationException -> {
            messages += "$prefix Failed to compile code: ${errorStyle(exception.message ?: "")}"
        }
        else -> {
            messages += "$prefix Unexpected exception: ${errorStyle(exception.message ?: "")}"
        }
    }
    exception.cause?.let { buildCompilationStackTrace(it, messages) }
}
