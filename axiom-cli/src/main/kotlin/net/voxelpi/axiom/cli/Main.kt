package net.voxelpi.axiom.cli

import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.ExperimentalCli
import kotlinx.cli.Subcommand
import kotlinx.cli.default
import net.voxelpi.axiom.arch.Architecture
import net.voxelpi.axiom.arch.ax08.AX08Architecture
import net.voxelpi.axiom.arch.dev64.DEV64Architecture
import net.voxelpi.axiom.arch.mcpc16.MCPC16Architecture
import net.voxelpi.axiom.arch.mcpc8.MCPC8Architecture
import net.voxelpi.axiom.asm.Assembler
import net.voxelpi.axiom.asm.exception.CompilationException
import net.voxelpi.axiom.asm.exception.ParseException
import net.voxelpi.axiom.asm.exception.SourceCompilationException
import net.voxelpi.axiom.asm.source.SourceLink
import net.voxelpi.axiom.emulator.EmulatedComputer
import net.voxelpi.axiom.instruction.Program
import net.voxelpi.axiom.util.parseInteger
import kotlin.io.path.Path
import kotlin.io.path.absolute
import kotlin.io.path.absolutePathString
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.isRegularFile
import kotlin.io.path.nameWithoutExtension
import kotlin.io.path.writeBytes
import kotlin.io.path.writeText
import kotlin.system.exitProcess
import kotlin.system.measureTimeMillis

@OptIn(ExperimentalCli::class)
fun main(args: Array<String>) {
    val parser = ArgParser("axiom")

    val architectures: Map<String, Architecture<*, *>> = listOf(
        AX08Architecture,
        DEV64Architecture,
        MCPC8Architecture,
        MCPC16Architecture,
    ).associateBy(Architecture<*, *>::id)

    class Assemble : Subcommand("assemble", "Assembles a program.") {
        val input by argument(ArgType.String, description = "The input file.")
        val output by option(ArgType.String, "output", "o", description = "The output file.")

        val architecture by option(
            ArgType.Choice(choices = architectures.values.toList(), toVariant = { architectures[it]!! }),
            fullName = "architecture",
            shortName = "a",
            description = "The architecture to use."
        ).default(AX08Architecture)

        override fun execute() {
            val inputFilePath = Path(input).absolute().normalize()
            if (!inputFilePath.exists() || !inputFilePath.isRegularFile()) {
                println("The input file $inputFilePath does not exist.")
                exitProcess(1)
            }

            val outputFilePath = (output?.let { Path(it) } ?: inputFilePath.parent.resolve(inputFilePath.nameWithoutExtension + ".bin")).normalize()
            println("Assembling \"${inputFilePath.absolutePathString()}\" to \"${outputFilePath.absolutePathString()}\"")

            val rawFile = outputFilePath.parent / "${outputFilePath.nameWithoutExtension}.raw.${Assembler.AXIOM_ASM_EXTENSION}"

            val assembler = Assembler(listOf(inputFilePath.parent.absolute().normalize()))

            val compilationTime = measureTimeMillis {
                val program = assembler.assemble(inputFilePath, architecture).getOrElse { exception ->
                    when (exception) {
                        is ParseException -> {
                            println(exception.message)
                        }
                        is SourceCompilationException -> {
                            val source = exception.source
                            when (source) {
                                is SourceLink.CompilationUnitSlice -> {
                                    println("Failed to compile code \"${source.text}\" in line ${source.line + 1}, ${source.column + 1} of unit \"${source.unit.id}\": ${exception.message}")
                                }
                                is SourceLink.Generated -> {
                                    println("Failed to compile code \"${source.text}\" generated by \"${source.generator}\": ${exception.message}")
                                }
                            }
                        }
                        is CompilationException -> {
                            println("Failed to compile code: ${exception.message}")
                        }
                        else -> {
                            throw exception
                        }
                    }
                    return@measureTimeMillis
                }

                rawFile.writeText(program.toString())

                if (architecture.hasEncodedFormat) {
                    val encodedProgram = architecture.encodeProgram(program).getOrThrow()
                    outputFilePath.writeBytes(encodedProgram.toByteArray())
                    print("Assembled ${program.instructions.size} instructions (${encodedProgram.size} bytes)")
                } else {
                    print("Assembled ${program.instructions.size} instructions")
                }
            }

            println(" in ${compilationTime}ms.")
        }
    }

    class Emulate() : Subcommand("emulate", "Emulates a program.") {
        val input by argument(ArgType.String, description = "The input file.")

        val architecture by option(
            ArgType.Choice(choices = architectures.values.toList(), toVariant = { architectures[it]!! }),
            fullName = "architecture",
            shortName = "a",
            description = "The architecture to use."
        ).default(AX08Architecture)

        override fun execute() {
            val inputFilePath = Path(input).absolute().normalize()
            if (!inputFilePath.exists() || !inputFilePath.isRegularFile()) {
                println("The input file $inputFilePath does not exist.")
                exitProcess(1)
            }
            println("Emulating \"${inputFilePath.absolutePathString()}\"")

            val assembler = Assembler(listOf(inputFilePath.parent.absolute().normalize()))

            val program: Program = assembler.assemble(inputFilePath, architecture).getOrElse { exception ->
                when (exception) {
                    is ParseException -> {
                        println(exception.message)
                    }
                    is SourceCompilationException -> {
                        val source = exception.source
                        when (source) {
                            is SourceLink.CompilationUnitSlice -> {
                                println("Failed to compile code \"${source.text}\" in line ${source.line + 1}, ${source.column + 1} of unit \"${source.unit.id}\": ${exception.message}")
                            }
                            is SourceLink.Generated -> {
                                println("Failed to compile code \"${source.text}\" generated by \"${source.generator}\": ${exception.message}")
                            }
                        }
                    }
                    is CompilationException -> {
                        println("Failed to compile code: ${exception.message}")
                    }
                    else -> {
                        throw exception
                    }
                }
                exitProcess(1)
            }

            val inputProvider: () -> ULong = {
                var result: ULong
                print("INPUT: ")
                while (true) {
                    val input = readln()

                    if (input.length == 3 && input[0] == '\'' && input[2] == '\'') {
                        result = input[1].code.toULong()
                        break
                    }

                    val integer = parseInteger(input)
                    if (integer != null) {
                        result = integer.toULong()
                        break
                    }
                    println("INVALID INPUT: \"$input\". Please enter a valid integer or character.")
                }

                result
            }

            val emulator = EmulatedComputer(architecture, program, inputProvider)
            while (true) {
                emulator.runUntilBreak()
                readlnOrNull() ?: break
            }
        }
    }

    parser.subcommands(Assemble(), Emulate())
    parser.parse(args)
}
