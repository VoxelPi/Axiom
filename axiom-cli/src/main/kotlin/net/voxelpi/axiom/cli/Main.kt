package net.voxelpi.axiom.cli

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.main
import com.github.ajalt.clikt.core.subcommands
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.arguments.optional
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.types.boolean
import com.github.ajalt.clikt.parameters.types.choice
import com.github.ajalt.clikt.parameters.types.int
import com.github.ajalt.clikt.parameters.types.path
import com.github.ajalt.mordant.rendering.TextColors
import com.github.ajalt.mordant.rendering.TextStyles
import com.github.ajalt.mordant.terminal.Terminal
import com.github.ajalt.mordant.widgets.Text
import net.voxelpi.axiom.arch.Architecture
import net.voxelpi.axiom.arch.ax08.AX08Architecture
import net.voxelpi.axiom.arch.dev08.DEV08Architecture
import net.voxelpi.axiom.arch.dev16.DEV16Architecture
import net.voxelpi.axiom.arch.dev32.DEV32Architecture
import net.voxelpi.axiom.arch.dev64.DEV64Architecture
import net.voxelpi.axiom.arch.mcpc08.MCPC08Architecture
import net.voxelpi.axiom.arch.mcpc16.MCPC16Architecture
import net.voxelpi.axiom.asm.Assembler
import net.voxelpi.axiom.asm.source.SourceLink
import net.voxelpi.axiom.cli.emulator.Emulator
import net.voxelpi.axiom.cli.util.generateCompilationStackTraceMessage
import kotlin.io.path.Path
import kotlin.io.path.absolute
import kotlin.io.path.absolutePathString
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.isRegularFile
import kotlin.io.path.nameWithoutExtension
import kotlin.io.path.writeBytes
import kotlin.io.path.writeText
import kotlin.system.exitProcess

class AxiomCommand : CliktCommand(name = "axiom") {

    override fun run() = Unit
}

class AssemblerCommand(
    val architectures: Map<String, Architecture>,
) : CliktCommand(name = "asm") {

    val input by argument(help = "The input file")
        .path(mustExist = true, canBeFile = true, canBeDir = false, mustBeReadable = true)
    val output by option(help = "The output file")
        .path()
    val position by option(help = "The position of the program in memory")
        .int()
        .default(0)
    val generateRaw by option("-r", "--raw", help = "If a raw axm file should be generated")
        .boolean()
        .default(false)
    val inverseInstructionByteOrder by option("-i", "--inverse", help = "If the instruction byte order should be inverted")
        .boolean()
        .default(false)
    val architecture by option("-a", "--arch", help = "Target architecture to assembled for")
        .choice(architectures)
        .default(AX08Architecture)

    override fun run() {
        val inputFilePath = input.absolute().normalize()
        if (!inputFilePath.exists() || !inputFilePath.isRegularFile()) {
            println("The input file $inputFilePath does not exist.")
            exitProcess(1)
        }

        val outputFilePath = (output ?: inputFilePath.parent.resolve(inputFilePath.nameWithoutExtension + ".bin")).normalize()
        println("Assembling \"${inputFilePath.absolutePathString()}\" to \"${outputFilePath.absolutePathString()}\"")

        val rawFile = outputFilePath.parent / "${outputFilePath.nameWithoutExtension}.raw.${Assembler.AXIOM_ASM_EXTENSION}"

        val assembler = Assembler(listOf(Path(".").absolute().normalize()))

        val program = assembler.assemble(inputFilePath, architecture, offset = position).getOrElse { exception ->
            echo(Text(TextColors.brightRed(TextStyles.bold("COMPILATION FAILED"))), err = true)
            echo(Text(generateCompilationStackTraceMessage(exception)), err = true)
            exitProcess(1)
        }

        if (generateRaw) {
            rawFile.writeText(
                program.data.joinToString("\n") { instruction ->
                    var text = instruction.toString().padEnd(32)
                    val source = instruction.meta[Assembler.SOURCE_INSTRUCTION_META_KEY] as? SourceLink
                    if (source != null) {
                        when (source) {
                            is SourceLink.CompilationUnitSlice -> {
                                text += " # ${"\"${source.text.trim()}\"".padEnd(32)} at ${source.line.toString().padStart(5)}:${source.column.toString().padEnd(2)} of unit \"${source.unit.id}\""
                            }

                            is SourceLink.Generated -> {
                                text += " # ${"\"${source.text.trim()}\"".padEnd(32)} generated by \"${source.generator}\""
                            }
                        }
                    }
                    text
                },
            )
        }

        if (architecture.hasEncodedFormat) {
            val encodedProgram = architecture.encodeProgram(program, invertByteOrder = inverseInstructionByteOrder).getOrThrow()
            outputFilePath.writeBytes(encodedProgram.toByteArray())
            println("Assembled ${program.data.size} instructions (${encodedProgram.size} bytes)")
        } else {
            println("Assembled ${program.data.size} instructions")
        }
    }
}

class EmulatorCommand(
    val architectures: Map<String, Architecture>,
) : CliktCommand(name = "emulator") {

    val program by argument(help = "The program")
        .path(mustExist = true, canBeFile = true, canBeDir = false, mustBeReadable = true)
        .optional()
    val architecture by option("-a", "--arch", help = "Target architecture to be emulated")
        .choice(architectures)
        .default(AX08Architecture)

    override fun run() {
        Emulator(architecture, program)
    }
}

fun main(args: Array<String>) {
    val terminal = Terminal()

    val architectures: Map<String, Architecture> = listOf(
        AX08Architecture,
        DEV08Architecture,
        DEV16Architecture,
        DEV32Architecture,
        DEV64Architecture,
        MCPC08Architecture,
        MCPC16Architecture,
    ).associateBy(Architecture::id)

    AxiomCommand()
        .subcommands(AssemblerCommand(architectures), EmulatorCommand(architectures))
        .main(args)
}
