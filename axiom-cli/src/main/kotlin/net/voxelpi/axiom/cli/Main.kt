package net.voxelpi.axiom.cli

import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.ExperimentalCli
import kotlinx.cli.Subcommand
import net.voxelpi.axiom.arch.mcpc16.MCPC16Architecture
import net.voxelpi.axiom.asm.Assembler
import net.voxelpi.axiom.asm.exception.CompilationException
import net.voxelpi.axiom.asm.exception.ParseException
import net.voxelpi.axiom.asm.exception.SourceCompilationException
import net.voxelpi.axiom.asm.source.SourceLink
import kotlin.io.path.Path
import kotlin.io.path.absolute
import kotlin.io.path.absolutePathString
import kotlin.io.path.exists
import kotlin.io.path.isRegularFile
import kotlin.io.path.nameWithoutExtension
import kotlin.system.exitProcess
import kotlin.system.measureTimeMillis

@OptIn(ExperimentalCli::class)
fun main(args: Array<String>) {
    val parser = ArgParser("axiom")

    class Assemble : Subcommand("assemble", "Assembles a program.") {
        val input: String by argument(ArgType.String, description = "The input file.")
        val output: String? by option(ArgType.String, "output", "o", description = "The output file.")

        override fun execute() {
            val inputFilePath = Path(input).absolute().normalize()
            if (!inputFilePath.exists() || !inputFilePath.isRegularFile()) {
                println("The input file $inputFilePath does not exist.")
                exitProcess(1)
            }

            val outputFilePath = output?.let { Path(it) } ?: inputFilePath.parent.resolve(inputFilePath.nameWithoutExtension + ".bin")
            println("Assembling \"${inputFilePath.normalize().absolutePathString()}\" to \"${outputFilePath.normalize().absolutePathString()}\"")

            val assembler = Assembler(listOf(inputFilePath.parent.absolute().normalize()))

            val compilationTime = measureTimeMillis {
                val program = assembler.assemble(inputFilePath, MCPC16Architecture).getOrElse { exception ->
                    when (exception) {
                        is ParseException -> {
                            println(exception.message)
                        }
                        is SourceCompilationException -> {
                            val source = exception.source
                            when (source) {
                                is SourceLink.CompilationUnitSlice -> {
                                    println("Failed to compile code \"${source.text}\" in line ${source.line + 1}, ${source.column + 1} of unit \"${source.unit.id}\": ${exception.message}")
                                }
                                is SourceLink.Generated -> {
                                    println("Failed to compile code \"${source.text}\" generated by \"${source.generator}\": ${exception.message}")
                                }
                            }
                        }
                        is CompilationException -> {
                            println("Failed to compile code: ${exception.message}")
                        }
                        else -> {
                            throw exception
                        }
                    }
                    return@measureTimeMillis
                }
            }

            println("Compilation took ${compilationTime}ms.")
        }
    }

    parser.subcommands(Assemble())
    parser.parse(args)
}
