package net.voxelpi.axiom.cli

import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.ExperimentalCli
import kotlinx.cli.Subcommand
import kotlinx.cli.default
import net.voxelpi.axiom.arch.Architecture
import net.voxelpi.axiom.arch.ax08.AX08Architecture
import net.voxelpi.axiom.arch.mcpc16.MCPC16Architecture
import net.voxelpi.axiom.arch.mcpc8.MCPC8Architecture
import net.voxelpi.axiom.asm.Assembler
import net.voxelpi.axiom.asm.exception.CompilationException
import net.voxelpi.axiom.asm.exception.ParseException
import net.voxelpi.axiom.asm.exception.SourceCompilationException
import net.voxelpi.axiom.asm.source.SourceLink
import kotlin.io.path.Path
import kotlin.io.path.absolute
import kotlin.io.path.absolutePathString
import kotlin.io.path.div
import kotlin.io.path.exists
import kotlin.io.path.isRegularFile
import kotlin.io.path.nameWithoutExtension
import kotlin.io.path.writeBytes
import kotlin.io.path.writeText
import kotlin.system.exitProcess
import kotlin.system.measureTimeMillis

@OptIn(ExperimentalCli::class)
fun main(args: Array<String>) {
    val parser = ArgParser("axiom")

    val architectures: Map<String, Architecture<*, *>> = listOf(
        MCPC8Architecture,
        MCPC16Architecture,
        AX08Architecture,
    ).associateBy(Architecture<*, *>::id)

    class Assemble : Subcommand("assemble", "Assembles a program.") {
        val input by argument(ArgType.String, description = "The input file.")
        val output by option(ArgType.String, "output", "o", description = "The output file.")

        val architecture by option(
            ArgType.Choice(choices = architectures.values.toList(), toVariant = { architectures[it]!! }),
            fullName = "architecture",
            shortName = "a",
            description = "The architecture to use."
        ).default(AX08Architecture)

        override fun execute() {
            val inputFilePath = Path(input).absolute().normalize()
            if (!inputFilePath.exists() || !inputFilePath.isRegularFile()) {
                println("The input file $inputFilePath does not exist.")
                exitProcess(1)
            }

            val outputFilePath = (output?.let { Path(it) } ?: inputFilePath.parent.resolve(inputFilePath.nameWithoutExtension + ".bin")).normalize()
            println("Assembling \"${inputFilePath.absolutePathString()}\" to \"${outputFilePath.absolutePathString()}\"")

            val rawFile = outputFilePath.parent / "${outputFilePath.nameWithoutExtension}.raw.${Assembler.AXIOM_ASM_EXTENSION}"

            val assembler = Assembler(listOf(inputFilePath.parent.absolute().normalize()))

            val compilationTime = measureTimeMillis {
                val program = assembler.assemble(inputFilePath, architecture).getOrElse { exception ->
                    when (exception) {
                        is ParseException -> {
                            println(exception.message)
                        }
                        is SourceCompilationException -> {
                            val source = exception.source
                            when (source) {
                                is SourceLink.CompilationUnitSlice -> {
                                    println("Failed to compile code \"${source.text}\" in line ${source.line + 1}, ${source.column + 1} of unit \"${source.unit.id}\": ${exception.message}")
                                }
                                is SourceLink.Generated -> {
                                    println("Failed to compile code \"${source.text}\" generated by \"${source.generator}\": ${exception.message}")
                                }
                            }
                        }
                        is CompilationException -> {
                            println("Failed to compile code: ${exception.message}")
                        }
                        else -> {
                            throw exception
                        }
                    }
                    return@measureTimeMillis
                }

                rawFile.writeText(program.toString())

                val encodedProgram = architecture.encodeProgram(program).getOrThrow()
                outputFilePath.writeBytes(encodedProgram.toByteArray())
                print("Assembled ${program.instructions.size} instructions (${encodedProgram.size} bytes)")
            }

            println(" in ${compilationTime}ms.")
        }
    }

    parser.subcommands(Assemble())
    parser.parse(args)
}
